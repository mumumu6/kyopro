from Crypto.Util.number import long_to_bytes
from sympy import *
from fractions import Fraction
import math
# 与えられたデータ
e = 135526321742256114741699879195750928560549959945172173014694553270714493327569040144991962356713501638089296024797104550184224096740962304461084115375825690723394880520437193172496966247265712152112985834808504146489458595748307376780786818314349759778353034156935455472066189805777855952441844968395407280071
n = 8241435966457349942143497911571909748315837818824435148214157188399917064520266575559546645955969944150933049734298283954766753409398227452899116909835694453251108868356146203625496583071862984535946614208098972801579152749367979365963816580948937778905359282382908416408984283538778223064170081578967903188827573
c = 5549369944475974388981536599962019273561677419836480146949817698192654329109988094596203290770619195602483624951915882233735333369476441442539732866619756188211074250629300955172619495465858470478302072586783048109234648795211247180466411113265106535301990338085662732887373022596163447943331839862542326485007496

# Wiener attack 実装
def wiener_attack(e, n):
    from fractions import Fraction

    def continued_fraction(n, d):
        while d:
            a = n // d
            yield a
            n, d = d, n - a * d

    def convergents(cf):
        num = 0
        den = 1
        for x in cf:
            num, den = den, x * den + num
            yield den, num

    for k, d in convergents(continued_fraction(e, n)):
        if k == 0:
            continue
        phi_candidate = (e * d - 1) // k
        s = n - phi_candidate + 1
        discr = s * s - 4 * n
        if discr >= 0:
            t = math.isqrt(discr)
            if t * t == discr and (s + t) % 2 == 0:
                return d
    return None

# 秘密鍵候補を探す
d = wiener_attack(e, n)

if d:
    m = pow(c, d, n)
    print("復号成功！")
    print(long_to_bytes(m))
else:
    print("Wiener攻撃では復号できませんでした。")
